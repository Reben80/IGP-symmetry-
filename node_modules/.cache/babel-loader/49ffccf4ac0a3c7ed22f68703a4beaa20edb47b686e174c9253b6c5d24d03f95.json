{"ast":null,"code":"import { drawOverlappingSquares } from './drawingUtils';\n\n// Easing function for smooth animation\nfunction easeInOutQuad(t) {\n  return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;\n}\nexport function transformCross(ctx, size, angle, reflectVertical = false, reflectHorizontal = false, reflectDiagonal1 = false, reflectDiagonal2 = false) {\n  const frames = 60;\n  let currentFrame = 0;\n  const canvasWidth = ctx.canvas.width;\n  const canvasHeight = ctx.canvas.height;\n  const centerX = 200;\n  const centerY = 200;\n  function animate() {\n    ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n    ctx.save();\n    ctx.translate(centerX, centerY);\n    if (reflectVertical || reflectHorizontal || reflectDiagonal1 || reflectDiagonal2) {\n      // Existing reflection code...\n    } else {\n      const progress = currentFrame / frames;\n      const easedProgress = easeInOutQuad(progress);\n      const rotationAngle = easedProgress * (angle * Math.PI / 180);\n\n      // Calculate the radius of the circular path\n      const radius = size / 2;\n\n      // Draw the curve path only if there's a rotation\n      if (angle !== 0) {\n        ctx.beginPath();\n        ctx.arc(0, 0, radius, 0, angle * Math.PI / 180, angle > 0);\n        ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';\n        ctx.stroke();\n      }\n\n      // Calculate the position on the circular path\n      const x = Math.sin(rotationAngle) * radius;\n      const y = radius - Math.cos(rotationAngle) * radius;\n\n      // Move to the calculated position and rotate\n      ctx.translate(x, y);\n      ctx.rotate(rotationAngle);\n    }\n    drawOverlappingSquares(ctx, size);\n    ctx.restore();\n\n    // Draw reflection lines only if a reflection is active\n    if (reflectVertical || reflectHorizontal || reflectDiagonal1 || reflectDiagonal2) {\n      ctx.setLineDash([5, 5]); // Dashed lines for reflection\n\n      if (reflectVertical) {\n        ctx.beginPath();\n        ctx.moveTo(centerX, 0);\n        ctx.lineTo(centerX, canvasHeight);\n        ctx.strokeStyle = 'rgba(0, 0, 255, 0.5)';\n        ctx.stroke();\n      }\n      if (reflectHorizontal) {\n        ctx.beginPath();\n        ctx.moveTo(0, centerY);\n        ctx.lineTo(canvasWidth, centerY);\n        ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';\n        ctx.stroke();\n      }\n      if (reflectDiagonal1) {\n        ctx.beginPath();\n        ctx.moveTo(0, 0);\n        ctx.lineTo(canvasWidth, canvasHeight);\n        ctx.strokeStyle = 'rgba(255, 165, 0, 0.5)'; // Orange\n        ctx.stroke();\n      }\n      if (reflectDiagonal2) {\n        ctx.beginPath();\n        ctx.moveTo(canvasWidth, 0);\n        ctx.lineTo(0, canvasHeight);\n        ctx.strokeStyle = 'rgba(128, 0, 128, 0.5)'; // Purple\n        ctx.stroke();\n      }\n      ctx.setLineDash([]); // Reset to solid lines\n    }\n    currentFrame++;\n    if (currentFrame < frames) {\n      requestAnimationFrame(animate);\n    }\n  }\n  animate();\n}\nexport function reflectSquare(ctx, x, y, size, direction) {\n  const frames = 30;\n  let currentFrame = 0;\n  function animate() {\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    ctx.save();\n    ctx.translate(x + size / 2, y + size / 2);\n    switch (direction) {\n      case 'horizontal':\n        ctx.scale(1 - currentFrame / frames * 2, 1);\n        break;\n      case 'vertical':\n        ctx.scale(1, 1 - currentFrame / frames * 2);\n        break;\n      case 'diagonal1':\n        ctx.rotate(Math.PI / 4);\n        ctx.scale(1, 1 - currentFrame / frames * 2);\n        ctx.rotate(-Math.PI / 4);\n        break;\n      case 'diagonal2':\n        ctx.rotate(-Math.PI / 4);\n        ctx.scale(1 - currentFrame / frames * 2, 1);\n        ctx.rotate(Math.PI / 4);\n        break;\n    }\n    drawOverlappingSquares(ctx, size);\n    ctx.restore();\n    currentFrame++;\n    if (currentFrame <= frames) {\n      requestAnimationFrame(animate);\n    }\n  }\n  animate();\n}","map":{"version":3,"names":["drawOverlappingSquares","easeInOutQuad","t","Math","pow","transformCross","ctx","size","angle","reflectVertical","reflectHorizontal","reflectDiagonal1","reflectDiagonal2","frames","currentFrame","canvasWidth","canvas","width","canvasHeight","height","centerX","centerY","animate","clearRect","save","translate","progress","easedProgress","rotationAngle","PI","radius","beginPath","arc","strokeStyle","stroke","x","sin","y","cos","rotate","restore","setLineDash","moveTo","lineTo","requestAnimationFrame","reflectSquare","direction","scale"],"sources":["/Users/Rebin/new symmetry /my-app/src/utils/transformUtils.ts"],"sourcesContent":["import { drawOverlappingSquares } from './drawingUtils';\n\n// Easing function for smooth animation\nfunction easeInOutQuad(t: number): number {\n  return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;\n}\n\nexport function transformCross(\n  ctx: CanvasRenderingContext2D, \n  size: number, \n  angle: number,\n  reflectVertical: boolean = false,\n  reflectHorizontal: boolean = false,\n  reflectDiagonal1: boolean = false,\n  reflectDiagonal2: boolean = false\n) {\n  const frames = 60;\n  let currentFrame = 0;\n\n  const canvasWidth = ctx.canvas.width;\n  const canvasHeight = ctx.canvas.height;\n  const centerX = 200;\n  const centerY = 200;\n\n  function animate() {\n    ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n\n    ctx.save();\n    ctx.translate(centerX, centerY);\n    \n    if (reflectVertical || reflectHorizontal || reflectDiagonal1 || reflectDiagonal2) {\n      // Existing reflection code...\n    } else {\n      const progress = currentFrame / frames;\n      const easedProgress = easeInOutQuad(progress);\n      const rotationAngle = easedProgress * (angle * Math.PI / 180);\n      \n      // Calculate the radius of the circular path\n      const radius = size / 2;\n      \n      // Draw the curve path only if there's a rotation\n      if (angle !== 0) {\n        ctx.beginPath();\n        ctx.arc(0, 0, radius, 0, angle * Math.PI / 180, angle > 0);\n        ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';\n        ctx.stroke();\n      }\n\n      // Calculate the position on the circular path\n      const x = Math.sin(rotationAngle) * radius;\n      const y = radius - Math.cos(rotationAngle) * radius;\n      \n      // Move to the calculated position and rotate\n      ctx.translate(x, y);\n      ctx.rotate(rotationAngle);\n    }\n    \n    drawOverlappingSquares(ctx, size);\n\n    ctx.restore();\n\n    // Draw reflection lines only if a reflection is active\n    if (reflectVertical || reflectHorizontal || reflectDiagonal1 || reflectDiagonal2) {\n      ctx.setLineDash([5, 5]); // Dashed lines for reflection\n      \n      if (reflectVertical) {\n        ctx.beginPath();\n        ctx.moveTo(centerX, 0);\n        ctx.lineTo(centerX, canvasHeight);\n        ctx.strokeStyle = 'rgba(0, 0, 255, 0.5)';\n        ctx.stroke();\n      }\n\n      if (reflectHorizontal) {\n        ctx.beginPath();\n        ctx.moveTo(0, centerY);\n        ctx.lineTo(canvasWidth, centerY);\n        ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';\n        ctx.stroke();\n      }\n\n      if (reflectDiagonal1) {\n        ctx.beginPath();\n        ctx.moveTo(0, 0);\n        ctx.lineTo(canvasWidth, canvasHeight);\n        ctx.strokeStyle = 'rgba(255, 165, 0, 0.5)'; // Orange\n        ctx.stroke();\n      }\n\n      if (reflectDiagonal2) {\n        ctx.beginPath();\n        ctx.moveTo(canvasWidth, 0);\n        ctx.lineTo(0, canvasHeight);\n        ctx.strokeStyle = 'rgba(128, 0, 128, 0.5)'; // Purple\n        ctx.stroke();\n      }\n\n      ctx.setLineDash([]); // Reset to solid lines\n    }\n\n    currentFrame++;\n\n    if (currentFrame < frames) {\n      requestAnimationFrame(animate);\n    }\n  }\n\n  animate();\n}\n\nexport function reflectSquare(\n  ctx: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  size: number,\n  direction: 'horizontal' | 'vertical' | 'diagonal1' | 'diagonal2'\n) {\n  const frames = 30;\n  let currentFrame = 0;\n\n  function animate() {\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\n    ctx.save();\n    ctx.translate(x + size / 2, y + size / 2);\n    \n    switch (direction) {\n      case 'horizontal':\n        ctx.scale(1 - (currentFrame / frames) * 2, 1);\n        break;\n      case 'vertical':\n        ctx.scale(1, 1 - (currentFrame / frames) * 2);\n        break;\n      case 'diagonal1':\n        ctx.rotate(Math.PI / 4);\n        ctx.scale(1, 1 - (currentFrame / frames) * 2);\n        ctx.rotate(-Math.PI / 4);\n        break;\n      case 'diagonal2':\n        ctx.rotate(-Math.PI / 4);\n        ctx.scale(1 - (currentFrame / frames) * 2, 1);\n        ctx.rotate(Math.PI / 4);\n        break;\n    }\n    \n    drawOverlappingSquares(ctx, size);\n    ctx.restore();\n\n    currentFrame++;\n\n    if (currentFrame <= frames) {\n      requestAnimationFrame(animate);\n    }\n  }\n\n  animate();\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}